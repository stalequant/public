<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hyperliquid and binance consolidated orderflow with stalegun demo</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.30.0/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css">
    
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: black;
            color: white;
        }
        #chart-container {
            width: 100%;
            height: 400px;
            position: relative;
            margin: 0 auto;
        }
        #watermark {
            position: absolute;
            font-size: 48px;
            opacity: 0.1;
            pointer-events: none;
        }
        #custom-legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 25px;
            cursor: pointer;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
        }
        .operation-form {

            margin-top: 20px;
        }
        .form-row {
	    color: white;
	    margin-left:20px;
            background-color: #111;
            display: flex;
            align-items: center;
        }


        .form-row label {
            display: inline-block;
            min-width: 100px;
        }
        input[type="number"] {
            width: 80px;        
	    background-color: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 5px;
        }
        button {
            margin-right: 10px;
            padding: 10px 20px;
            border: none;
            background-color: #222;
            color: #ccc;
            font-size: .8em;
            cursor: pointer;
            transition: background-color 0.3s;
            text-transform: uppercase;
        }
        button.selected {
            background-color: #5a6d9e;
            color: #fff;
        }
        .button-group {
            display: flex;
            gap: 0px;
        }
        .button-group button {
            flex: 1;
        }
        .expandable {
            background-color: #222;
            padding: 10px;
            display: none;
            margin-top: 5px;
        }
        .expandable div {
            margin-bottom: 10px;
        }
        .expandable p {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 0;
        }
        .expandable button {
            margin: 2px;
            padding: 5px 10px;
        }
        .action-buttons {
            margin-top: 15px;
            text-decoration: line-through;
        }
        .action-buttons button {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #5a6d9e;

        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #222;
        }
        .cancel-button {
            background-color: #722;
            color: #fff;
            padding: 5px 10px;
        }
        .cancel-all-button {
            background-color: #722;
            color: #fff;
            padding: 5px 10px;
            margin: 0;
        }
        .time-slider {
            width: 80%;
            margin: 5px 0;
        }

	.ui-autocomplete {
            background-color: #000;
            color: #fff;
            border: 1px solid #555;
            max-height: 200px;
            overflow-y: auto;
        }
        .ui-menu-item-wrapper {
            padding: 5px;
        }
        .ui-state-active {
            background-color: #5a6d9e;
            color: #fff;
        }
        #coinInput {
            width: 120px;
            background-color: #000;
            color: #fff;
            border: 1px solid #555;
            padding: 5px;
        }

    </style>
</head>
<body>
    <div class="operation-form">
        <div class="form-row">
            <label>stalegun aimed at </label>
 <input type="text" id="coinInput" placeholder="BTC" style="margin:10px;"></input>
</div></div>

    <div id="chart-container">
        <div id="watermark">stalequant.github.io/public/</div>
        <canvas id="coinChart"></canvas>
    </div>
    <div id="custom-legend"></div>

    <div class="operation-form">
        <div class="form-row">
 <label  >
order stalegun airstrike 
</label>
	</div>
        <div class="form-row">
            <label>what?</label>
            <div class="button-group">
                <button onclick="setOperation('buy', this)">BUY</button>
                <button onclick="setOperation('sell', this)">SELL</button>
            </div>
            <input type="number" id="quantity" placeholder="quantity" style="  margin-left: 10px;">
            <input type="number" id="dollars" placeholder="dollars" style="  margin-left: 10px;">     
        </div>
        </div>
        <div class="form-row">            <label>over:</label>
            <input type="range" id="timeInterval" min="0" max="100" value="50">
            <span id="timeIntervalValue">12 hours</span>
        </div>
        <div class="form-row ppp">
            <label>how?</label>
            <div class="button-group">
                <button onclick="setAdaptive('adaptive', this)">ADAPTIVE</button>
                <button onclick="setAdaptive('aggressive', this)">AGGRESSIVE</button>
                <button onclick="setAdaptive('price', this)">CHEAPEST</button>
                <button onclick="toggleDetails(this)">CUSTOM</button>
            </div>
        </div>

        <div id="details" class="expandable">
            <div>
                <p>taker:</p>
                <button onclick="toggleDetail(this)">HIDDEN TWAP</button>
                <button onclick="toggleDetail(this)">PSEUDO-VWAP</button>
                <button onclick="toggleDetail(this)">SNIPE LIMITS</button>
            </div>
            <div>
                <p>maker:</p>
                <button onclick="toggleDetail(this)">TOP OF THE BOOK</button>
                <button onclick="toggleDetail(this)">DEEP BOOK</button>
            </div>
            <div>
                <p>offchain:</p>
                <button onclick="toggleDetail(this)">MATCH WITH OTHER USERS</button>
                <button onclick="toggleDetail(this)">DARK POOLS</button>
                <button onclick="toggleDetail(this)">RFQ</button>
            </div>
        </div>
        <div class="form-row action-buttons">
            <button>DEMO IT</button>
            <button>DO IT</button>
<label>(canceled because i fear litiguous burgers)</label>
        </div>
    </div>

    <div class="operation-form">
 <div  class = "form form-row">
existing stalegun airstrikes 
</div> 
 <div  class = "form form-row" style="width:100%">
    <table>
        <tr>
            <th>operation</th>
            <th>done</th>
            <th>of</th>
            <th>after</th>
            <th>of</th>
            <th>at price</th>
            <th><button class="cancel-all-button" onclick="cancelAllOperations()">CANCEL ALL</button></th>
        </tr>
    </table>
</div>
</div>


    <script>
        // Get the coin from URL parameters
        const urlParams = new URLSearchParams(window.location.search);

	const coin = urlParams.get('coin') || 'BTC'; 
	const colorHL = '#44BEA4';
 	   const colorBN = '#FF8424';
  	  const colorBNS = '#A444BE';
	const colorTrans = '#000000';
	var hiddenLines = ['binance spot','bid-ask']; 
const venueDtypeMapping = {};
	
	const locToStr = ( venue, dtype, side) =>{
		return venue + 'x' +dtype+ 'x' + (side? 'b':'s');

}
        const addData = (venue, dtype, side, time, value)  => {
            venueDtypeMapping[locToStr(venue, dtype, side)].data.push({x: time, y: value});
        }

const createBaseDataset = (venue, dtype, color, buy) => {
  let newDataset =  {
    venue,
    dtype,
    data: [],
    borderColor: color,
    borderWidth: 2,
    pointRadius: 0,
    stepped: true
  };
  venueDtypeMapping[locToStr(venue,dtype,buy)] = newDataset;
  return newDataset;
};

const createTradeDataset = (venue, dtype, color, buy) => ({
  ...createBaseDataset(venue, dtype, color, buy),
  pointRadius: 7,
  pointStyle: 'triangle',
  pointBackgroundColor: colorTrans,
  pointRotation: buy ? 0 : 180, 
  showLine: false
});

const createBidAskDataset = (venue, dtype, color, buy) => ({
  ...createBaseDataset(venue, dtype, color, buy),
  backgroundColor: `${color}10`, 
  borderColor: `${color}77`,
  borderWidth: 2,
  fill: buy? "+1":"-1",
});

const createDepthDataset = (venue, dtype, color, buy, ) => ({
  ...createBidAskDataset(venue, dtype, color, buy,),
  backgroundColor: `${color}10`, 
});

 
  
	const exchanges = [
  { name: 'hyperliquid', color: colorHL },
  { name: 'binance futures', color: colorBN },
  { name: 'binance spot', color: colorBNS }
];

const datasetTypes = [
  { name: 'trades', fn: createTradeDataset },
  { name: 'bid-ask', fn: createBidAskDataset },
  { name: '$5k spread', fn: createDepthDataset }
];
 function customTickGenerator(min, max, stepSize) {
    const ticks = [];
    let curr = Math.ceil(0.5 + min / stepSize) * stepSize;
    while (curr <= max - stepSize/2) {
        ticks.push({
            value: curr,
            label: new Date(curr).toISOString(),  // Or any other format you prefer
            major: false
        });
        curr += stepSize;
    }
    return ticks;
}
		    const reqLiq = 5000;

const stepSizeMs = 5000; // 5 second
        const ctx = document.getElementById('coinChart').getContext('2d');
        const coinChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: exchanges.flatMap(exchange => 
  datasetTypes.flatMap(dataset => [
    dataset.fn(exchange.name, dataset.name, exchange.color, true),
    dataset.fn(exchange.name, dataset.name, exchange.color, false)
  ])
)      },
            options: {
                responsive: true,
		maintainAspectRatio: false,
                animation: false,
                scales: {
                         x: {
        type: 'time',
        grid: {
            display: false,
            color: 'rgba(255, 255, 255, 0.1)'
        },
        time: {
            unit: 'second',
            stepSize: 5,
            displayFormats: {
                second: 'HH:mm:ss'
            },
        },
        ticks: {
            source: 'data',
            autoSkip: false,
            maxRotation: 0,
            color: 'white'
        },
        min: undefined,
        max: undefined,
        afterBuildTicks: function(scale) {
            scale.ticks = customTickGenerator(scale.min, scale.max, stepSizeMs);
        }
    },
                    y: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: 'white',

          maxTicksLimit: 5
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        enabled: false
                    },
                    legend: {
                        display: false
                    }
                }
            }
        });

        // Custom legend
        const legendItems = [
            { text: 'hyperliquid', color: colorHL, style: 'square'},
            { text: 'binance futures', color: colorBN, style: 'square'},
            { text: 'binance spot', color: colorBNS, style: 'square'},
            { text: 'trades', color: 'white', style: 'circle' },
            { text: '$5k spread', color: 'white', style: 'line' },
            { text: 'bid-ask', color: 'rgba(255,255,255,0.3)', style: 'square'}
        ];

        const legendContainer = document.getElementById('custom-legend');
        legendItems.forEach((item, index) => {
            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            
            const color = document.createElement('div');
            color.className = 'legend-color';
            color.style.backgroundColor = item.color;
            if (item.style === 'line') {
                color.style.height = '2px';
                color.style.marginTop = '4px';
                color.style.marginBottom = '4px';
            } else if (item.style === 'circle') {
                color.style.borderRadius = '50%';
            }
            
            const text = document.createElement('span');
            text.className = 'legend-text';
            text.textContent = item.text;
            
            legendItem.appendChild(color);
            legendItem.appendChild(text);
            legendContainer.appendChild(legendItem);
            
    legendItem.onclick = function() {
        const itemText = item.text;
	if (hiddenLines.includes(item.text)){
		hiddenLines = hiddenLines.filter(elem => elem !== item.text);
	} else { 
     	 	hiddenLines.push(itemText);  // Fixed: use push correctly
	}
	
        for (let i = 0; i < coinChart.data.datasets.length; i++) {
        	const meta = coinChart.getDatasetMeta(i);
	        meta.hidden = hiddenLines.includes(meta._dataset.venue) || hiddenLines.includes(meta._dataset.dtype);
        }

	coinChart.update();
    };
});

        for (let i = 0; i < coinChart.data.datasets.length; i++) {
        	const meta = coinChart.getDatasetMeta(i);
	        meta.hidden = hiddenLines.includes(meta._dataset.venue) || hiddenLines.includes(meta._dataset.dtype);
        }
 

      ctx.globalCompositeOperation = 'destination-over';
	coinChart.update();

        const dataWindow = 30000; // 30 seconds of data
        let lastUpdateTime = Date.now();

        const wshyperliquid = new WebSocket('wss://api.hyperliquid.xyz/ws');
        const wsbinanceBookTicker = new WebSocket(`wss://fstream.binance.com/ws/${coin.toLowerCase()}usdt@depth20@100ms`);
        const wsbinanceAggTrade = new WebSocket(`wss://fstream.binance.com/ws/${coin.toLowerCase()}usdt@aggTrade`);
        const wsbinanceSpotBookTicker = new WebSocket(`wss://stream.binance.com:443/ws/${coin.toLowerCase()}usdt@depth20@100ms`);
        const wsbinanceSpotAggTrade = new WebSocket(`wss://stream.binance.com:443/ws/${coin.toLowerCase()}usdt@aggTrade`);

	var binanceLag = 0

        wshyperliquid.onopen = function() {
            console.log('hyperliquid WebSocket is connected');
            wshyperliquid.send(JSON.stringify({
                "method": "subscribe",
                "subscription": { "type": "l2Book", "coin": coin }
            }));
            wshyperliquid.send(JSON.stringify({
                "method": "subscribe",
                "subscription": { "type": "trades", "coin": coin }
            }));
        };


        wshyperliquid.onmessage = function(event) {
	    let venue = 'hyperliquid';
            const message = JSON.parse(event.data);

            if (message.channel === "l2Book" && message.data.coin === coin) {
                const timestamp = parseFloat(message.data.time);
                const levels = message.data.levels;
                if (levels && levels.length >= 2) {
                    addData(venue,'bid-ask',true, timestamp, parseFloat(levels[0][0].px));
                    addData(venue,'bid-ask',false, timestamp, parseFloat(levels[1][0].px));

                    let sum = 0;
                    let i = 0;
                    while (i < levels[0].length && sum < reqLiq) {
                        sum += parseFloat(levels[0][i].sz) * parseFloat(levels[0][i].px);
                        i++;
                    }
                    if (sum >= reqLiq) {
                        deepBid = parseFloat(levels[0][i-1].px);
                    } else if (levels[0].length > 0) {
                        deepBid = parseFloat(levels[0][levels[0].length - 1].px) / 1.01;
                    }
		    
                    let sumA = 0;
                    let iA = 0;
                    while (iA < levels[1].length && sumA < reqLiq) {
                        sumA += parseFloat(levels[1][iA].sz) * parseFloat(levels[1][i].px);
                        iA++;
                    }
                    if (sumA >= reqLiq) {
                        deepAsk = parseFloat(levels[1][iA-1].px);
                    } else if (levels[1].length > 0) {
                        deepAsk = parseFloat(levels[1][levels[1].length - 1].px) * 1.01;
                    } 
                    addData(venue,'$5k spread',true, timestamp, deepBid);
                    addData(venue,'$5k spread',false, timestamp, deepAsk);
                }
            }

            if (message.channel === "trades" && message.data.length > 0) {


                message.data.forEach(trade => {
                    if (trade.coin === coin) {   
                        const tradePrice = parseFloat(trade.px);
                        const timestamp = trade.time;
                 	addData(venue,'trades',trade.side === "B", timestamp, tradePrice);
                    }
                });
            }
        };

        wshyperliquid.onerror = function(error) {
            console.error('hyperliquid WebSocket Error: ', error);
        };

        wshyperliquid.onclose = function() {
            console.log('hyperliquid WebSocket is closed');
        };



        wsbinanceBookTicker.onopen = function() {
            console.log('binance BookTicker WebSocket is connected');
        };

        wsbinanceBookTicker.onmessage = function(event) {
            const message = JSON.parse(event.data);
	    let venue = 'binance futures';

            if (message.e === "depthUpdate" && message.s === `${coin}USDT`) {	
	            const timestamp = parseFloat(message.E);
                    addData(venue,'bid-ask',true, timestamp, parseFloat(message.b[0][0]));
                    addData(venue,'bid-ask',false, timestamp, parseFloat(message.a[0][0]));




                    let sum = 0;
                    let i = 0;
                    while (i < message.b.length && sum < reqLiq) {
                        sum += parseFloat(message.b[i][1]) * parseFloat(message.b[i][0]);
                        i++;
                    }
                    if (i <2 || sum >= reqLiq) {
                        deepBid = parseFloat(message.b[i-1][0]);
                    } else if (message.b.length > 0) {
                        deepBid = parseFloat(message.b[message.b.length - 1][0]) / 1.01;
                    }
		    
                    let sumA = 0;
                    let iA = 0;
                    while (iA < message.a.length && sumA < reqLiq) {
                        sumA += parseFloat(message.a[iA][1]) * parseFloat(message.a[iA][0]);
                        iA++;
                    }
                    if (iA <2 || sumA >= reqLiq) {
                        deepAsk = parseFloat(message.a[iA-1][0]);
                    } else if (message.a.length > 0) {
                        deepAsk = parseFloat(message.a[message.a.length - 1][0]) * 1.01;
                    }
			
 
                    addData(venue,'$5k spread',true, timestamp, deepBid);
                    addData(venue,'$5k spread',false, timestamp, deepAsk);

		    let measuredLag = timestamp - Date.now() ;
		    binanceLag = binanceLag * .8 + measuredLag*.2;


            }
        };

        wsbinanceAggTrade.onopen = function() {
            console.log('binance AggTrade WebSocket is connected');
        };

        wsbinanceAggTrade.onmessage = function(event) {
	    const venue = 'binance futures';
            const message = JSON.parse(event.data);
            if (message.e === "aggTrade" && message.s === `${coin}USDT`) {
                const tradePrice = parseFloat(message.p);
                const timestamp = message.T;
	        addData(venue, 'trades', !message.m, timestamp, tradePrice); // binance Trades
            }
        };

        wsbinanceBookTicker.onerror = function(error) {
            console.error('binance BookTicker WebSocket Error: ', error);
        };

        wsbinanceBookTicker.onclose = function() {
            console.log('binance BookTicker WebSocket is closed');
        };

        wsbinanceAggTrade.onerror = function(error) {
            console.error('binance AggTrade WebSocket Error: ', error);
        };

        wsbinanceAggTrade.onclose = function() {
            console.log('binance AggTrade WebSocket is closed');
        };





        wsbinanceSpotBookTicker.onopen = function() {
            console.log('binanceSpot BookTicker WebSocket is connected');
        };

        wsbinanceSpotBookTicker.onmessage = function(event) {
		const venue = 'binance spot';
            const message = JSON.parse(event.data);
            const currentTime = Date.now();
	            const timestamp = parseFloat(message.E);
                     addData(venue,'bid-ask',true, timestamp, parseFloat(message.bids[0][0]));
                    addData(venue,'bid-ask',false, timestamp, parseFloat(message.asks[0][0]));






                    let sum = 0;
                    let i = 0;
                    while (i < message.bids.length && sum < reqLiq) {
                        sum += parseFloat(message.bids[i][1]) * parseFloat(message.bids[i][0]);
                        i++;
                    }
                    if (i <2 || sum >= reqLiq) {
                        deepBid = parseFloat(message.bids[i-1][0]);
                    } else if (message.bids.length > 0) {
                        deepBid = parseFloat(message.bids[message.bids.length - 1][0]) / 1.01;
                    }
		    
                    let sumA = 0;
                    let iA = 0;
                    while (iA < message.asks.length && sumA < reqLiq) {
                        sumA += parseFloat(message.asks[iA][1]) * parseFloat(message.asks[iA][0]);
                        iA++;
                    }
                    if (iA <2 || sumA >= reqLiq) {
                        deepAsk = parseFloat(message.asks[iA-1][0]);
                    } else if (message.asks.length > 0) {
                        deepAsk = parseFloat(message.asks[message.asks.length - 1][0]) * 1.01;
                    }
                   
		    addData(venue,'$5k spread',true, currentTime+binanceLag, deepBid);
                    addData(venue,'$5k spread',false, currentTime+binanceLag, deepAsk);



        };

        wsbinanceSpotAggTrade.onopen = function() {
            console.log('binanceSpot AggTrade WebSocket is connected');
        };

        wsbinanceSpotAggTrade.onmessage = function(event) {
	    const venue = 'binance spot';
            const message = JSON.parse(event.data);
            if (message.e === "aggTrade" && message.s === `${coin}USDT`) {
                const tradePrice = parseFloat(message.p);
                const timestamp = message.T;
	        addData(venue, 'trades', !message.m, timestamp, tradePrice); // binance Trades
            }
        };




        wsbinanceSpotBookTicker.onerror = function(error) {
            console.error('binanceSpot BookTicker WebSocket Error: ', error);
        };

        wsbinanceSpotBookTicker.onclose = function() {
            console.log('binanceSpot BookTicker WebSocket is closed');
        };

        wsbinanceSpotAggTrade.onerror = function(error) {
            console.error('binanceSpot AggTrade WebSocket Error: ', error);
        };

        wsbinanceSpotAggTrade.onclose = function() {
            console.log('binanceSpot AggTrade WebSocket is closed');
        };




function updateChart(currentTime) {
    const oldestAllowedTime = currentTime - dataWindow * 1.5;

    coinChart.data.datasets.forEach(dataset => {
        let i = 0;
        while (i < dataset.data.length && dataset.data[i].x < oldestAllowedTime) {
            i++;
        }
        if (i > 0) {
            dataset.data.splice(0, i);
        }
    });

    coinChart.options.scales.x.min = currentTime - dataWindow;
    coinChart.options.scales.x.max = currentTime;

    coinChart.update('none');
}

        // Smooth scrolling update loop
        function smoothScroll() {
    const currentTime = Date.now();
    updateChart(currentTime);
    requestAnimationFrame(smoothScroll);
}

        smoothScroll(); // Start the smooth scrolling




        function toggleDetails(button) {
            const details = document.getElementById('details');
            if (details.style.display === 'none' || details.style.display === '') {
                details.style.display = 'block';
                button.classList.add('selected');
            } else {
                details.style.display = 'none';
                button.classList.remove('selected');
            }
        }

        function setOperation(op, button) {
            console.log('Operation set to:', op);
            clearSelection(button.parentNode);
            button.classList.add('selected');
        }

        function setAdaptive(type, button) {
            console.log('Adaptive type set to:', type);
            clearSelection(button.parentNode);
            button.classList.add('selected');
            document.getElementById('details').style.display = 'none';
        }

        function toggleDetail(button) {
            button.classList.toggle('selected');
        }

        function clearSelection(parent) {
            parent.querySelectorAll('button').forEach(btn => btn.classList.remove('selected'));
        }

        function cancelOperation(operationId) {
            console.log('Canceling operation:', operationId);
            // Add logic to cancel the specific operation
        }

        function cancelAllOperations() {
            console.log('Canceling all operations');
            // Add logic to cancel all operations
        }

        const timeInterval = document.getElementById('timeInterval');
        const timeIntervalValue = document.getElementById('timeIntervalValue');
        
        function logSlider(position) {
            // position will be between 0 and 100
            const minp = 0;
            const maxp = 100;

            // The result should be between 1 minute and 1 day (in minutes)
            const minv = Math.log(10);
            const maxv = Math.log(1440*7);

            // calculate adjustment factor
            const scale = (maxv - minv) / (maxp - minp);

            return Math.exp(minv + scale * (position - minp));
        }

        function formatTime(minutes) {
            if (minutes < 60) {
                return Math.round(minutes) + ' minutes';
            } else if (minutes < 1440) {
                return (minutes / 60).toFixed(1) + ' hours';
            } else {              
                return (minutes / 60/24).toFixed(1) + ' days';
            }
        }

        timeInterval.addEventListener('input', function() {
            const logValue = logSlider(this.value);
            timeIntervalValue.textContent = formatTime(logValue);
        });

        // Initialize the slider value
        timeInterval.value = 60;
        timeInterval.dispatchEvent(new Event('input'));

        const coinParam = urlParams.get('coin') || 'BTC'; 
        const coins = ['AAVE', 'ACE', 'ADA', 'AI', 'ALT', 'APE', 'APT', 'AR', 'ARB', 'ARK', 'ATOM', 'AVAX', 'BADGER', 'BANANA', 'BCH', 'BIGTIME', 'BLUR', 'BLZ', 'BNB', 'BNT', 'BOME', 'BRETT', 'BSV', 'BTC', 'CAKE', 'CFX', 'COMP', 'CRV', 'CYBER', 'DOGE', 'DOT', 'DYDX', 'DYM', 'ENA', 'ENS', 'ETC', 'ETH', 'ETHFI', 'FET', 'FIL', 'FTM', 'FTT', 'FXS', 'GALA', 'GAS', 'GMT', 'GMX', 'HBAR', 'ILV', 'IMX', 'INJ', 'IO', 'JTO', 'JUP', 'KAS', 'LDO', 'LINK', 'LISTA', 'LOOM', 'LTC', 'MANTA', 'MATIC', 'MAV', 'MAVIA', 'MEME', 'MEW', 'MINA', 'MKR', 'MYRO', 'NEAR', 'NEO', 'NOT', 'NTRN', 'OGN', 'OMNI', 'ONDO', 'OP', 'ORBS', 'ORDI', 'PENDLE', 'PEOPLE', 'PIXEL', 'POLYX', 'POPCAT', 'PYTH', 'RDNT', 'RENDER', 'REZ', 'RSR', 'RUNE', 'SAGA', 'SEI', 'SNX', 'SOL', 'STG', 'STRAX', 'STRK', 'STX', 'SUI', 'SUPER', 'SUSHI', 'TAO', 'TIA', 'TNSR', 'TON', 'TRB', 'TRX', 'TURBO', 'UMA', 'UNI', 'USTC', 'W', 'WIF', 'WLD', 'XAI', 'XRP', 'YGG', 'ZEN', 'ZETA', 'ZK', 'ZRO'];

        $(document).ready(function() {
            $('#coinInput').val(coinParam);
            
            $('#coinInput').autocomplete({
                source: coins,
                select: function(event, ui) {
                    window.location.href = '?coin=' + ui.item.value;
                }
            });
        });
    </script>
</body>
</html>
